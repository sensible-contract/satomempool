package main

import (
	"encoding/base64"
	"encoding/binary"
	"encoding/hex"
	"log"

	"github.com/ybbus/jsonrpc/v2"
	"github.com/zeromq/goczmq"
)

var rpcClient jsonrpc.RPCClient

func init() {
	rpcAddress := "http://localhost:16332"
	rpcClient = jsonrpc.NewClientWithOpts(rpcAddress, &jsonrpc.RPCClientOpts{
		CustomHeaders: map[string]string{
			"Authorization": "Basic " + base64.StdEncoding.EncodeToString([]byte("jie"+":"+"jIang_jIe1234567")),
		},
	})
}

func main() {
	endpoint := "tcp://192.168.31.236:16331"

	subscriber, err := goczmq.NewSub(endpoint, "rawtx,hashtx,hashblock")
	defer subscriber.Destroy()
	if err != nil {
		log.Fatal(err)
	}

	log.Printf("ZeroMQ started to listen for blocks")

	for {

		msg, n, err := subscriber.RecvFrame()
		if err != nil {
			log.Printf("Error ZMQ RecFrame: %s", err)
		}

		if len(msg) == 32 {
			log.Printf("sub received: %d, %s", n, hex.EncodeToString(msg))

			response, err := rpcClient.Call("getmempoolentry", []string{hex.EncodeToString(msg)})
			if err != nil {
				log.Println("call failed:", err)
				return
			}

			log.Println("Receive remote return:", response)

			// if response.Error != nil {
			// 	return
			// }

		} else if len(msg) == 4 {
			log.Printf("id: %d, %d", n, binary.LittleEndian.Uint32(msg))

		} else if len(msg) == 5 || len(msg) == 6 || len(msg) == 9 {
			log.Printf("sub received: %d, %s", n, string(msg))
		} else {
			log.Printf("sub received: %d, %s", n, hex.EncodeToString(msg))
		}
	}
}
